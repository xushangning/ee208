\documentclass[main.tex]{subfiles}
\begin{document}
\section{后端}
\paragraph{} 在后端我们采用了Flask来实现网页框架。这主要有两点原因：其一是Flask的兼容性很好，尤其是它与我们的前端语言Vue是相容的，这是前后端联系的基础；其二在于它的设计简洁，但较web.py功能更完备，尤其是在python环境下（事实上它正是用python编写的）。
\subsection{实现}
\paragraph{} 在后端我们实现了四个数据处理过程。
\paragraph{} 其一是关于电影名称的搜索。这一点我们通过GET方法获取到前端的input数据后，通过模糊匹配来得到搜索结果（因为输入的文本很可能是不完全的电影名），并根据相关性得分进行排名，最后返回。
\paragraph{} 其二是对某个确定电影的相关信息的呈现。这是通过精确匹配完成的，不须分词，所以在这一步我们使用了另一个索引（其之前索引的区别仅仅在于未对电影名分词）。
\paragraph{} 其三是对电影预告片的截图进行搜索。这里我们先将传来的文件暂存到本地，再用opencv读取，通过对截图的处理得到截图中的字幕，然后与索引中的字幕进行模糊匹配，取相似度最高者返回结果。
\paragraph{} 其四是对电影海报的搜索。这与预告片搜索相类，只是匹配是与电影名进行匹配。
\subsection{问题与对策}
\paragraph{} 相比于之前的学习内容，对上传文件的内容搜索是一个新的问题（之前一直停留在文本搜索的阶段）。对此我们通过调用Flask提供的文件管理函数，先将文件存储至本地，在进行读取和计算，从而解决了该问题。

\section{引擎}
\paragraph{} 我们选择了elasticsearch作为本次大作业的搜索引擎。基于lunece开发的elasticsearch相比lunece，其功能更为成熟，且为分布式搜索引擎，在存储空间、安全性以及搜索速度等方面的性能都更胜一筹。
\subsection{实现}
\paragraph{} 首先，正如之前提到的，我们准备了两份索引，一份对应模糊搜索，另一份用于精确搜索。
\paragraph{} 我们将爬取到的电影文本信息以及图片信息一一对应，用字典的形式（也即是对象形式，对象形式也是elasticsearch文档要求的存储形式）封装起来，并对各项信息添加索引。
\subsection{问题与对策}
\subsubsection{索引设置}
\paragraph{} 索引设置，更准确一点来说是调整索引的mapping的过程中，我们遇到了一些困难。首先是elasticsea
rch与python的接口使用起来颇为不便，无法灵活地进行参数设置。我们在试图调用ik\_max\_word分词器的时候用python接口始终无法成功。最终我们重新调整了ik\_max\_word的路径，然后用curl在命令行中发送网络请求检查并修改索引的mapping，交互问题才得到解决。而对于各字段的设置，则是通过多次比较得出的结论。
\subsubsection{电影信息}
\paragraph{} 原本在爬虫阶段我们已经将文件顺序做了一一对应，但在读取的时候发现电影信息整合之后并非正确的对应关系，于是我们只好又对文件顺序进行了重新排序。然后，在之后的检查过程中我们还发现存在极少数文件是空的，另外存在.DS\_Store文件（Mac系统下产生的附加文件），这些都导致了读取时的错误。由于这些文件数量极少，我们最终采取忽略的方式解决。
	
	
\end{document}